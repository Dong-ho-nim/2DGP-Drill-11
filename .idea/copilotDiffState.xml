<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/ball.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ball.py" />
              <option name="originalContent" value="from pico2d import *&#10;import game_world&#10;import game_framework&#10;&#10;PIXEL_PER_METER = (1.0 / 0.03)  # 1pixel = 3cm, 1m = 33.33 pixel&#10;GRAVITY = 9.8  # 중력 가속도 (m/s²)&#10;&#10;class Ball:&#10;    image = None&#10;&#10;    def __init__(self, x=400, y=300, throwin_speed=15, throwin_angle=45):&#10;        if Ball.image == None:&#10;            Ball.image = load_image('ball21x21.png')&#10;        self.x, self.y = x, y&#10;        self.xv = throwin_speed * math.cos(math.radians(throwin_angle))  # m/s&#10;        self.yv = abs(throwin_speed * math.sin(math.radians(throwin_angle)))  # m/s&#10;        self.stopped = True if throwin_speed == 0.0 else False&#10;&#10;    def draw(self):&#10;        self.image.draw(self.x, self.y)&#10;        draw_rectangle(*self.get_bb())&#10;&#10;&#10;    def update(self):&#10;        if self.stopped:&#10;            return&#10;        # 위치 업데이트&#10;        self.x += self.xv * game_framework.frame_time * PIXEL_PER_METER&#10;        self.y += self.yv * game_framework.frame_time * PIXEL_PER_METER&#10;&#10;        # y 축 속도에 중력 가속도 적용&#10;        self.yv -= GRAVITY * game_framework.frame_time  # m/s&#10;&#10;    def get_bb(self):&#10;        return self.x - 10, self.y - 10, self.x + 10, self.y + 10&#10;&#10;    def handle_collision(self, group, other):&#10;        if group == 'boy:ball':&#10;            game_world.remove_object(self)&#10;        elif group == 'grass:ball':&#10;            self.stopped = True&#10;        elif group == 'zombie:ball':&#10;            # 좀비와 충돌하면 볼 제거&#10;            game_world.remove_object(self)" />
              <option name="updatedContent" value="from pico2d import *&#10;import game_world&#10;import game_framework&#10;&#10;PIXEL_PER_METER = (1.0 / 0.03)  # 1pixel = 3cm, 1m = 33.33 pixel&#10;GRAVITY = 9.8  # 중력 가속도 (m/s²)&#10;&#10;class Ball:&#10;    image = None&#10;&#10;    def __init__(self, x=400, y=300, throwin_speed=15, throwin_angle=45):&#10;        if Ball.image == None:&#10;            Ball.image = load_image('ball21x21.png')&#10;        self.x, self.y = x, y&#10;        self.xv = throwin_speed * math.cos(math.radians(throwin_angle))  # m/s&#10;        self.yv = abs(throwin_speed * math.sin(math.radians(throwin_angle)))  # m/s&#10;        self.stopped = True if throwin_speed == 0.0 else False&#10;&#10;    def draw(self):&#10;        self.image.draw(self.x, self.y)&#10;        draw_rectangle(*self.get_bb())&#10;&#10;&#10;    def update(self):&#10;        if self.stopped:&#10;            return&#10;        # 위치 업데이트&#10;        self.x += self.xv * game_framework.frame_time * PIXEL_PER_METER&#10;        self.y += self.yv * game_framework.frame_time * PIXEL_PER_METER&#10;&#10;        # y 축 속도에 중력 가속도 적용&#10;        self.yv -= GRAVITY * game_framework.frame_time  # m/s&#10;&#10;    def get_bb(self):&#10;        return self.x - 10, self.y - 10, self.x + 10, self.y + 10&#10;&#10;    def handle_collision(self, group, other):&#10;        if group == 'boy:ball':&#10;            game_world.remove_object(self)&#10;        elif group == 'grass:ball':&#10;            self.stopped = True&#10;        elif group == 'zombie:ball':&#10;            # 좀비와 충돌하면 볼 제거&#10;            game_world.remove_object(self)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/game_world.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/game_world.py" />
              <option name="originalContent" value="world = [[] for _ in range(4)]&#10;collision_pairs = {}&#10;&#10;def add_collision_pair(group, a, b):&#10;    if group not in collision_pairs:&#10;        print(f'Added new group {group}')&#10;        collision_pairs[group] = [[], []]&#10;    if a:&#10;        collision_pairs[group][0].append(a)&#10;    if b:&#10;        collision_pairs[group][1].append(b)&#10;&#10;def remove_collision_object(o):&#10;    for pairs in collision_pairs.values():&#10;        if o in pairs[0]:&#10;            pairs[0].remove(o)&#10;        if o in pairs[1]:&#10;            pairs[1].remove(o)&#10;&#10;def handle_collisions():&#10;    for group, pairs in collision_pairs.items():&#10;        for a in pairs[0]:&#10;            for b in pairs[1]:&#10;                if collide(a, b):&#10;                    a.handle_collision(group, b)&#10;                    b.handle_collision(group, a)&#10;&#10;&#10;def add_object(o, depth = 0):&#10;    world[depth].append(o)&#10;&#10;&#10;def add_objects(ol, depth = 0):&#10;    world[depth] += ol&#10;&#10;&#10;def update():&#10;    for layer in world:&#10;        for o in layer:&#10;            o.update()&#10;&#10;&#10;def render():&#10;    for layer in world:&#10;        for o in layer:&#10;            o.draw()&#10;&#10;def collide(a, b):&#10;    left_a, bottom_a, right_a, top_a = a.get_bb()&#10;    left_b, bottom_b, right_b, top_b = b.get_bb()&#10;&#10;    if left_a &gt; right_b: return False&#10;    if right_a &lt; left_b: return False&#10;    if top_a &lt; bottom_b: return False&#10;    if bottom_a &gt; top_b: return False&#10;&#10;    return True&#10;    pass&#10;&#10;def remove_object(o):&#10;    for layer in world:&#10;        if o in layer:&#10;            layer.remove(o)&#10;            remove_collision_object(o)&#10;            return&#10;    raise ValueError('Cannot delete non existing object')&#10;&#10;&#10;def clear():&#10;    for layer in world:&#10;        layer.clear()&#10;&#10;&#10;&#10;&#10;&#10;" />
              <option name="updatedContent" value="world = [[] for _ in range(4)]&#10;collision_pairs = {}&#10;&#10;def add_collision_pair(group, a, b):&#10;    if group not in collision_pairs:&#10;        print(f'Added new group {group}')&#10;        collision_pairs[group] = [[], []]&#10;    # 중복 추가 방지&#10;    if a and a not in collision_pairs[group][0]:&#10;        collision_pairs[group][0].append(a)&#10;    if b and b not in collision_pairs[group][1]:&#10;        collision_pairs[group][1].append(b)&#10;&#10;def remove_collision_object(o):&#10;    for pairs in collision_pairs.values():&#10;        if o in pairs[0]:&#10;            pairs[0].remove(o)&#10;        if o in pairs[1]:&#10;            pairs[1].remove(o)&#10;&#10;def handle_collisions():&#10;    for group, pairs in collision_pairs.items():&#10;        # 복사본을 순회하여 충돌 처리 중 목록 변경에도 안전&#10;        for a in list(pairs[0]):&#10;            for b in list(pairs[1]):&#10;                if collide(a, b):&#10;                    a.handle_collision(group, b)&#10;                    b.handle_collision(group, a)&#10;&#10;&#10;def add_object(o, depth = 0):&#10;    world[depth].append(o)&#10;&#10;&#10;def add_objects(ol, depth = 0):&#10;    world[depth] += ol&#10;&#10;&#10;def update():&#10;    for layer in world:&#10;        for o in layer:&#10;            o.update()&#10;&#10;&#10;def render():&#10;    for layer in world:&#10;        for o in layer:&#10;            o.draw()&#10;&#10;def collide(a, b):&#10;    left_a, bottom_a, right_a, top_a = a.get_bb()&#10;    left_b, bottom_b, right_b, top_b = b.get_bb()&#10;&#10;    if left_a &gt; right_b: return False&#10;    if right_a &lt; left_b: return False&#10;    if top_a &lt; bottom_b: return False&#10;    if bottom_a &gt; top_b: return False&#10;&#10;    return True&#10;    pass&#10;&#10;def remove_object(o):&#10;    # 레이어에서 제거 시도&#10;    for layer in world:&#10;        if o in layer:&#10;            layer.remove(o)&#10;            remove_collision_object(o)&#10;            return&#10;    # 레이어에 없어도 충돌 목록에서 제거만 하고 조용히 반환&#10;    remove_collision_object(o)&#10;    return&#10;&#10;&#10;def clear():&#10;    for layer in world:&#10;        layer.clear()&#10;    collision_pairs.clear()" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>